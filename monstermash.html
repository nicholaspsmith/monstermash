<!DOCTYPE html>
<html>
<head>
  <title>Animation Object</title>
  <style>
    canvas {
      cursor: crosshair;
    }
  </style>
</head>
<canvas width="128" height="128"></canvas>

<script>
var monster = {
  IMAGE: 'monsterTileSheet.png',
  SIZE: 128,
  COLUMNS: 3,
  numberOfFrames: 5,
  currentFrame: 0,
  sourceX: 0,
  sourceY: 0,

  //animation direction
  forward: true,

  //state
  HIDING: 0,
  JUMPING: 1,
  HIT: 2,
  state: this.HIDING,

  //properties to reset animation
  timeToReset: 9,
  resetCounter: 0,

  //store random time to wait
  waitTime: undefined,

  //method to find a random animation time
  findWaitTime: function() {
    this.waitTime = Math.ceil(Math.random() * 60);
  },

  updateAnimation: function() {
    if (this.state !== this.HIT) {
      if(this.waitTime > 0 || this.waitTime === undefined) {
        this.state = this.HIDING;
      } else {
        this.state = this.JUMPING;
      }
    }

    switch(this.state) {
      case this.HIDING:
        this.currentFrame = 0;
        this.waitTime--;
        break;
      case this.JUMPING:
        //if last frame has been reached, set forward to false
        if(this.currentFrame === this.numberOfFrames) {
          this.forward = false;
        }
        //if the first frame has been reached, set forward to true
        if(this.currentFrame === 0 && this.forward === false) {
          //set forward to true, find a new waitTime
          this.forward = true;
          this.findWaitTime();
          // set the state to HIDING and break the switch statement
          this.state = this.HIDING;
        }
        break;
      case this.HIT:
        //set the current frame to the last one on the tilesheet
        this.currentFrame = 6;

        //update reset counter by 1
        this.resetCounter++;

        //reset the animation if the restCounter equals the timeToReset
        if(this.resetCounter === this.timeToReset) {
          this.state = this.HIDING;
          this.forward = true;
          this.currentFrame = 0;
          this.resetCounter = 0;
          this.findWaitTime();
        }
        break;
    }

    this.sourceX = Math.floor(this.currentFrame % this.COLUMNS) * this.SIZE;
    this.sourceY = Math.floor(this.currentFrame / this.COLUMNS) * this.SIZE;
    if (this.forward) {
      this.currentFrame++;
    } else {
      this.currentFrame--;
    }
  }
};

var canvas = document.querySelector('canvas');
var ctx = canvas.getContext('2d');
canvas.addEventListener('mousedown', mousedownHandler, false);

var image = new Image();
image.addEventListener('load',loadHandler,false);
image.src = monster.IMAGE;

function loadHandler() {
  monster.findWaitTime();
  updateAnimation();
}

function updateAnimation() {
  setTimeout(updateAnimation, 120);
  monster.updateAnimation();
  render();
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(
    image,
    monster.sourceX, monster.sourceY, monster.SIZE, monster.SIZE,
    0, 0, monster.SIZE, monster.SIZE
  );
}

function mousedownHandler() {
  if (monster.state === monster.JUMPING){
    monster.state = monster.HIT;
  }
}

</script>
</html>
